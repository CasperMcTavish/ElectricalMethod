# -*- coding: utf-8 -*-
"""
tests use of UI generated by qt5-designer
Code taken from pyqtgraph examples (VideoTest)
"""
import socket
import binascii
#from pyqtgraph.Qt import QtGui, QtCore, USE_PYSIDE, USE_PYQT5
from pyqtgraph.Qt import QtGui, QtCore, USE_PYQT5
#from PyQt5.QtWidgets import
import numpy as np
import pyqtgraph as pg
import pyqtgraph.ptime as ptime
#
import dwaTools as dwa
from datetime import datetime

# configure pyqtgraph (must come before plots are instantiated)
pg.setConfigOption('background', 'w') # white background
pg.setConfigOption('foreground', 'k') # black foreground
pg.setConfigOptions(antialias=True)   # prettier plots

# GUI layout made in qt5-designer
import dwaGui    

#QtGui.QApplication.setGraphicsSystem('raster')
app = QtGui.QApplication([])

win = QtGui.QMainWindow()
ui = dwaGui.Ui_MainWindow()
ui.setupUi(win)
#win.setWindowTitle('DWA DAQ (updated)')

############ Launch GUI so that it is in bottom right corner
# only tested on linux (should work on mac, unclear about windows)
# https://stackoverflow.com/questions/39046059/pyqt-location-of-the-window
screen = QtGui.QDesktopWidget().screenGeometry() 
wgeom  = win.geometry()
x = screen.width() - wgeom.width()
y = screen.height() - wgeom.height()
win.move(x,y)
###########################

win.show()

# access/control widgets
ui.configFile.setText("dwaConfig.ini")

# log data to disk!
#outputfilename = 'receivedData.txt'
# socket communication
sock = ''




def getUniqueFileroot():
    now = datetime.now()
    return now.strftime("data/%Y%m%dT%H%M%S")

regIds = dwa.registerNames()
nReg = len(regIds)
print("nReg = {}".format(nReg))

idxOfRegId = {} # numerical index for each Register (0..nReg-1)
fhOfRegId = {}  # file handles for output
for ir in range(nReg):
    idxOfRegId[regIds[ir]] = ir
    fhOfRegId[regIds[ir]] = None

print("idxOfRegId = ")
print(idxOfRegId)
print("fhOfRegId = ")
print(fhOfRegId)

# set up UDP connection
def configureUdp():
    global sock  # FIXME: remove? since you return sock anyway...
    try:
        sock = socket.socket(family=socket.AF_INET,  # internet
                             type=socket.SOCK_DGRAM) # UDP
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind( (UDP_IP, UDP_PORT) )
        sock.settimeout(15)
    except:
        print("UDP ERROR: could not setup UDP")
        sock = None
    return sock

def udpCleanup():
    pass

UDP_IP = ''       # '' is a symbolic name meaning all available interfaces
UDP_PORT = 6008   # port (set to match the hard-coded value on the FPGA)
udpBufferSize = 1024*1 # max amount of data to be received at once (in bytes?)
tokSize = 8 # length of each token (token is a 8-entry HEX value like 'CAFE8030')
encoding = 'utf-8'

def show(msg, term=False):
    "add text to loggin window"
    ui.outputText.appendPlainText(msg)
    if term:
        print(msg)
    app.processEvents()


# data to plot
pdata = []   # voltage (for voltage vs. time)
tdata = []   # times (for voltage vs. time)
ampls = []   # amplitude (for ampl. vs. freq)
freqs = []   # freq (for ampl. vs. freq)

for ix in range(nReg):
    pdata.append([])   # one list for each register
    tdata.append([])
    ampls.append([])
    freqs.append([])

def updateAmplVsFreqPlot(pdataOfReg, hdr, regId):
    regIdx = idxOfRegId[regId]
    amplEst = 0.5*(np.max(pdataOfReg)-np.min(pdataOfReg))  # FIXME: should fit sinewave?
    ampls[regIdx].append(amplEst) 
    print("hdr = ")
    print(hdr)
    freqs[regIdx].append(hdr['STIM_FREQ_HZ'])
    # update plot
    # FIXME: need a separate plot (p2) for every register...
    p2.setData(freqs[regIdx], ampls[regIdx])
    app.processEvents() ## force complete redraw for every plot



def udpCommencePlease():

    global pdata, p2, sock

    print("udpCommencePlease():")

    print("START SETTING UP FOR NEW RUN")
    # want result to be a string like 'CAFE805E'
    lastLine = ''

    # create new output filename
    fnOfRegId = {}  # file names for output
    froot = getUniqueFileroot()
    for ir in range(nReg):
        fnOfRegId[regIds[ir]] = "{}_{}.txt".format(froot, regIds[ir])
    print("fnOfRegId = ")
    print(fnOfRegId)

    # clear plots on screen
    p1.setData([], [])
    p2.setData([], [])
    app.processEvents()
    headerDict = {} # info from data headers 'CAFE...'
    for ir in range(nReg):
        headerDict[regIds[ir]] = {}
    print("DONE SETTING UP FOR NEW RUN")

    while(True):
        try:
            data, source_addr = sock.recvfrom(udpBufferSize)   
            # if you don't want recvfrom() to block, then use 
            # data, addr = sock.recvfrom(udpBufferSize, socket.MSG_DONTWAIT)   
            # which will return None in place of valid data.
            # Note: source_addr is a tuple (source_ip, source_port)
            # where source_ip is the IP address of the sender (microzed)
            # and source_port is an ephemeral UDP port that is 
            # automatically assigned by the operating system
            # This page very helpful for UDP communication:
            # http://hacked10bits.blogspot.com/2014/12/udp-binding-and-port-reuse-in-linux.html
            msg = "\n\nbing! Data received from:\n{}".format(source_addr)
            print(msg)
            dataStr = binascii.hexlify(data)

            #if data is coming from FPGA then there is a UDP packet header
            dataToks = [ str(dataStr[ii:ii+tokSize], 'utf-8').upper() 
                         for ii in range(0, len(dataStr), tokSize) ]
            udpHeader = dataToks[0:2]
            dataToks  = dataToks[2:]
            
            # FIXME: from udp header, check for missing packets
            # FIXME: and figure out which file to write to
            regId = udpHeader[1][-2:]   # e.g. '1F'
            regIdx = idxOfRegId[regId]

            # Ensure that data file is open for writing
            # we'll leave it open until the run is finished
            if fhOfRegId[regId] == None:
                fhOfRegId[regId] = open(fnOfRegId[regId], 'w')
                # and create a soft-link to regId.last
                dwa.force_symlink(fnOfRegId[regId], '1F.last')

            # Quickly write the data to file
            for line in dataToks:
                fhOfRegId[regId].write(line)
                fhOfRegId[regId].write('\n')
                fhOfRegId[regId].flush()      # FIXME: is this too time-consuming?

            # Then process the data for graphing
            # (should this be a separate thread that reads the datafile?)
            for line in udpHeader:
                show(line, term=False)
                print("UDP: {}".format(line))

            for line in dataToks:
                show(line, term=False)
                print("   : {}".format(line))

            for dataStr in dataToks:
            
                if dataStr.startswith('CAFE'):  # data header line 1
                    # Do analysis on the last dataset (assuming that there was one!)
                    # reset the data array
                    # FIXME: this means we will miss the last stimulation frequency
                    # since there is no 'CAFE' header after it.  Need a way to know
                    # when a dataset from a given frequency is completed.
                    
                    # Update the data set for plotting
                    # fit sine-wave to data from last stimulation frequency
                    if len(pdata[regIdx]) > 0:
                        updateAmplVsFreqPlot(pdata[regIdx], headerDict[regId], regId)
            
                    lastLine = dataStr
                    continue
                    
                if lastLine.startswith('CAFE'): # data header line 2
                    show("Parsing header")
                    print("  {}".format(lastLine), end="")
                    print("  {}".format(dataStr))
                    #headerDict = dwa.parseUdpHeader(lastLine, dataStr, verbose=False)
                    headerDict[regId] = dwa.parseDwaDataHeader(lastLine, dataStr, verbose=False)
                    print("headerDict = ")
                    print(headerDict)
                    lastLine = ''
                    pdata[regIdx].clear()
                    continue
                
                pdata[regIdx] += dwa.parseUdpDataLine(dataStr)
                lastLine = dataStr

        except socket.timeout:
            #show('except')
            sock.close()
            print("socket timeout")
            #ui.outputText.appendPlainText("socket timeout")

            # FIXME: we may not always want to update this plot...
            #updateAmplVsFreqPlot(pdata, headerDict)

            lastLine = ''
            dataStr = ''

            print("fhOfRegId (before closing) = ")
            print(fhOfRegId)
            for regId in regIds:
                pdata[idxOfRegId[regId]].clear()
                freqs[idxOfRegId[regId]].clear()
                ampls[idxOfRegId[regId]].clear()
                if fhOfRegId[regId]:         # close the open files
                    fhOfRegId[regId].close()
                    fhOfRegId[regId] = None
            print("fhOfRegId (after closing) = ")
            print(fhOfRegId)
            udpCleanup()
            break
        
        # update the voltage vs. time plot
        p1.setData(np.arange(len(pdata[regIdx])), pdata[regIdx])
        app.processEvents()


def onClick():
    print("clicked...")
    print('config file name = {}'.format(ui.configFile.text()))
    ui.outputText.appendPlainText("starting UDP transfer")
    configureUdp()
    udpCommencePlease()

ui.pushButton.clicked.connect(onClick)

###############################################################


#def update():
#    ui.outputText.appendPlainText("tick")

# Create an empty plot curve to be filled later, set its pen
# FIXME: need one of these plots for every register
p1 = ui.voltageVsTime.plot(pen='r') 
# FIXME: need one of these plots for every register
p2 = ui.amplVsFreq.plot(pen='y', symbolBrush=(0,0,200), symbolPen='w', symbol='o', symbolSize=10)

# fixme: move to UI generator???
ui.voltageVsTime.setLabel('left', 'Volts', units='V')
ui.voltageVsTime.setLabel('bottom', 'Time', units='s')
ui.amplVsFreq.setLabel('left', 'Amplitude', units='V')
ui.amplVsFreq.setLabel('bottom', 'Frequency', units='Hz')

## Start Qt event loop unless running in interactive mode or using pyside.
if __name__ == '__main__':
    import sys
    if (sys.flags.interactive != 1) or not hasattr(QtCore, 'PYQT_VERSION'):
        QtGui.QApplication.instance().exec_()
